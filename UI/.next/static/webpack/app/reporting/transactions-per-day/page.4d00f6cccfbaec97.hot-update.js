"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reporting/transactions-per-day/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProcessorCount: () => (/* binding */ fetchProcessorCount),\n/* harmony export */   fetchProcessorData: () => (/* binding */ fetchProcessorData),\n/* harmony export */   fetchRejectedTransactionsCount: () => (/* binding */ fetchRejectedTransactionsCount),\n/* harmony export */   fetchReportingByCard: () => (/* binding */ fetchReportingByCard),\n/* harmony export */   fetchReportingByCardType: () => (/* binding */ fetchReportingByCardType),\n/* harmony export */   fetchReportingByDay: () => (/* binding */ fetchReportingByDay),\n/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatDateTime: () => (/* binding */ formatDateTime),\n/* harmony export */   getBearerToken: () => (/* binding */ getBearerToken),\n/* harmony export */   mapTransactionStatus: () => (/* binding */ mapTransactionStatus),\n/* harmony export */   submitProcessorData: () => (/* binding */ submitProcessorData)\n/* harmony export */ });\n// Use environment variable with fallback\nconst BASE_URL = \"https://localhost:7039\" || 0;\nconst ITEMS_PER_PAGE = 25;\nconst BEARER_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODUxNDA5ODQsImlhdCI6MTQ4NTEzNzM4NCwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiIyOWFjMGMxOC0wYjRhLTQyY2YtODJmYy0wM2Q1NzAzMThhMWQiLCJhcHBsaWNhdGlvbklkIjoiNzkxMDM3MzQtOTdhYi00ZDFhLWFmMzctZTAwNmQwNWQyOTUyIiwicm9sZXMiOltdfQ.Mp0Pcwsz5VECK11Kf2ZZNF_SMKu5CgBeLN9ZOP04kZo';\nasync function fetchProcessorCount(cardNumber, status) {\n    try {\n        const response = await fetch(\"\".concat(BASE_URL, \"/ProcessorCount?cardNumber=\").concat(cardNumber, \"&status=\").concat(status), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getBearerToken())\n            }\n        });\n        const count = await response.json();\n        const totalPages = Math.ceil(Number(count) / ITEMS_PER_PAGE);\n        return totalPages;\n    } catch (error) {\n        console.error('Error fetching processor count:', error);\n        return 0;\n    }\n}\nasync function fetchProcessorData(pageNum, cardNumber, status) {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/Processor?pageNumber=\").concat(pageNum, \"&cardNumber=\").concat(cardNumber || '', \"&status=\").concat(status || ''));\n        const response = await fetch(\"\".concat(BASE_URL, \"/Processor?pageNumber=\").concat(pageNum, \"&cardNumber=\").concat(cardNumber || '', \"&status=\").concat(status || ''), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getBearerToken())\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const transactions = await response.json();\n        console.log('Raw transaction data:', transactions);\n        // Ensure we have a valid array\n        if (!Array.isArray(transactions)) {\n            console.error('API did not return an array:', transactions);\n            return [];\n        }\n        // Map and validate the data\n        const validatedTransactions = transactions.map((item)=>({\n                id: Number(item.id || 0),\n                cardNumber: String(item.cardNumber || ''),\n                cardType: String(item.cardType || ''),\n                amount: Number(item.amount || 0),\n                transactionTimeStamp: String(item.transactionTimeStamp || ''),\n                transactionStatus: Number(item.transactionStatus || 0),\n                transactionProcessedTimeStamp: String(item.transactionProcessedTimeStamp || '')\n            }));\n        return validatedTransactions;\n    } catch (error) {\n        console.error('Error fetching processor data:', error);\n        return [];\n    }\n}\nasync function fetchRejectedTransactionsCount() {\n    try {\n        console.log(\"Calling API for rejected count: \".concat(BASE_URL, \"/ProcessorCount?status=Rejected\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ProcessorCount?status=Rejected\"), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getBearerToken())\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const count = await response.json();\n        console.log('Rejected transactions count:', count);\n        const totalPages = Math.ceil(Number(count) / ITEMS_PER_PAGE);\n        console.log(\"Total pages for rejected transactions: \".concat(totalPages));\n        return totalPages;\n    } catch (error) {\n        console.error('Error fetching rejected transactions count:', error);\n        return 0;\n    }\n}\nasync function fetchReportingByCard() {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/ReportingByCard\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ReportingByCard\"), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getBearerToken())\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const results = await response.json();\n        console.log('Raw API response:', results);\n        // Ensure we have a valid array\n        if (!Array.isArray(results)) {\n            console.error('API did not return an array:', results);\n            return [];\n        }\n        // Map and validate the data structure\n        const cardReports = results.map((item)=>({\n                cardNumber: String(item.cardNumber || ''),\n                transactionCount: Number(item.transactionCount || 0),\n                totalAmount: Number(item.totalAmount || 0)\n            }));\n        return cardReports;\n    } catch (error) {\n        console.error('Error fetching reporting by card:', error);\n        return [];\n    }\n}\nasync function fetchReportingByCardType() {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/ReportingByCardType\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ReportingByCardType\"));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const results = await response.json();\n        console.log('Raw API response:', results);\n        // Ensure we have a valid array\n        if (!Array.isArray(results)) {\n            console.error('API did not return an array:', results);\n            return [];\n        }\n        // Map and validate the data\n        const cardTypeReports = results.map((item)=>({\n                cardType: String(item.cardType || ''),\n                transactionCount: Number(item.transactionCount || 0),\n                totalAmount: Number(item.totalAmount || 0)\n            }));\n        return cardTypeReports;\n    } catch (error) {\n        console.error('Error fetching reporting by card type:', error);\n        return [];\n    }\n}\nasync function fetchReportingByDay() {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/ReportingByDay\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ReportingByDay\"));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const results = await response.json();\n        console.log('Raw API response:', results);\n        // Ensure we have a valid array\n        if (!Array.isArray(results)) {\n            console.error('API did not return an array:', results);\n            return [];\n        }\n        // Map and validate the data\n        const dailyReports = results.map((item)=>({\n                transactionDate: String(item.transactionDate || ''),\n                transactionCount: Number(item.transactionCount || 0),\n                totalAmount: Number(item.totalAmount || 0)\n            }));\n        return dailyReports;\n    } catch (error) {\n        console.error('Error fetching reporting by day:', error);\n        return [];\n    }\n}\nasync function submitProcessorData(type, data) {\n    try {\n        // Always use uppercase for format type as expected by API\n        const dataType = type.toUpperCase();\n        console.log(\"Submitting \".concat(dataType, \" data to \").concat(BASE_URL, \"/Processor\"));\n        console.log(\"Input format type: \".concat(type, \", normalized to: \").concat(dataType));\n        // Important: The API expects \"type\" as the property name, not \"dataType\"\n        const bulkTransaction = {\n            type: dataType,\n            data: data\n        };\n        console.log('Request payload structure:', {\n            type: bulkTransaction.type,\n            dataLength: bulkTransaction.data.length,\n            dataSample: bulkTransaction.data.substring(0, 50) + '...'\n        });\n        const response = await fetch(\"\".concat(BASE_URL, \"/Processor/bulk\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(bulkTransaction)\n        });\n        console.log('API response status:', response.status);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"API Error (\".concat(response.status, \"):\"), errorText);\n            throw new Error(\"Server returned \".concat(response.status, \": \").concat(errorText || response.statusText));\n        }\n        const result = await response.json().catch(()=>({\n                message: 'Data submitted successfully'\n            }));\n        console.log('API Response:', result);\n        return result;\n    } catch (error) {\n        console.error('Error submitting processor data:', error);\n        throw error;\n    }\n}\nfunction formatDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n        month: '2-digit',\n        day: '2-digit',\n        year: 'numeric'\n    });\n}\nfunction formatDateTime(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n        month: '2-digit',\n        day: '2-digit',\n        year: 'numeric'\n    }) + ' ' + date.toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false\n    });\n}\nfunction formatCurrency(amount) {\n    return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD',\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount);\n}\nfunction mapTransactionStatus(status) {\n    switch(status){\n        case 1:\n            return 'Accepted';\n        case 2:\n            return 'Rejected';\n        default:\n            return 'Unknown';\n    }\n}\nfunction getBearerToken() {\n    // Return the cached token or get a new one if expired or missing, based on credentials.  \n    // This will need to be changed with real authentication logic.\n    return BEARER_TOKEN;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU87UUFDUEMsVUFBVTtRQUNWQyx1QkFBdUI7UUFDdkJDLHVCQUF1QjtJQUN6QixHQUFHQyxNQUFNLENBQUN4RDtBQUNaO0FBRU8sU0FBU3lELHFCQUFxQnBGLE1BQWM7SUFDakQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPO0lBQ1g7QUFDRjtBQUVPLFNBQVNJO0lBQ2QsMEZBQTBGO0lBQzFGLCtEQUErRDtJQUMvRCxPQUFPUDtBQUNUIiwic291cmNlcyI6WyJJOlxcR0lUXFxTaWduYVBheVxcUHJvY2Vzc29yLUludGVydmlld1xccHJvY2Vzc29yLWludGVydmlld1xcVUlcXGxpYlxcYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcbmltcG9ydCB7IENhcmRSZXBvcnQsIENhcmRUeXBlUmVwb3J0LCBEYWlseVJlcG9ydCwgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbi8vIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIGZhbGxiYWNrXHJcbmNvbnN0IEJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIHx8ICdodHRwczovL2xvY2FsaG9zdDo3MDM5JztcclxuY29uc3QgSVRFTVNfUEVSX1BBR0UgPSAyNTtcclxuY29uc3QgQkVBUkVSX1RPS0VOID0gJ2V5SmhiR2NpT2lKSVV6STFOaUlzSW5SNWNDSTZJa3BYVkNKOS5leUpsZUhBaU9qRTBPRFV4TkRBNU9EUXNJbWxoZENJNk1UUTROVEV6TnpNNE5Dd2lhWE56SWpvaVlXTnRaUzVqYjIwaUxDSnpkV0lpT2lJeU9XRmpNR014T0Mwd1lqUmhMVFF5WTJZdE9ESm1ZeTB3TTJRMU56QXpNVGhoTVdRaUxDSmhjSEJzYVdOaGRHbHZia2xrSWpvaU56a3hNRE0zTXpRdE9UZGhZaTAwWkRGaExXRm1NemN0WlRBd05tUXdOV1F5T1RVeUlpd2ljbTlzWlhNaU9sdGRmUS5NcDBQY3dzejVWRUNLMTFLZjJaWk5GX1NNS3U1Q2dCZUxOOVpPUDA0a1pvJztcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByb2Nlc3NvckNvdW50KGNhcmROdW1iZXI/OiBzdHJpbmcsIHN0YXR1cz86IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgdHJ5IHsgICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9Qcm9jZXNzb3JDb3VudD9jYXJkTnVtYmVyPSR7Y2FyZE51bWJlcn0mc3RhdHVzPSR7c3RhdHVzfWAsIHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2dldEJlYXJlclRva2VuKCl9YFxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgIGNvbnN0ICB0b3RhbFBhZ2VzID0gTWF0aC5jZWlsKE51bWJlcihjb3VudCkgLyBJVEVNU19QRVJfUEFHRSk7IFxyXG5cclxuICAgIHJldHVybiB0b3RhbFBhZ2VzO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvY2Vzc29yIGNvdW50OicsIGVycm9yKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvY2Vzc29yRGF0YShwYWdlTnVtOiBudW1iZXIsIGNhcmROdW1iZXI/OiBzdHJpbmcsIHN0YXR1cz86IHN0cmluZyk6IFByb21pc2U8VHJhbnNhY3Rpb25bXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgQ2FsbGluZyBBUEk6ICR7QkFTRV9VUkx9L1Byb2Nlc3Nvcj9wYWdlTnVtYmVyPSR7cGFnZU51bX0mY2FyZE51bWJlcj0ke2NhcmROdW1iZXIgfHwgJyd9JnN0YXR1cz0ke3N0YXR1cyB8fCAnJ31gKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L1Byb2Nlc3Nvcj9wYWdlTnVtYmVyPSR7cGFnZU51bX0mY2FyZE51bWJlcj0ke2NhcmROdW1iZXIgfHwgJyd9JnN0YXR1cz0ke3N0YXR1cyB8fCAnJ31gLCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbigpfWBcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVzcG9uZGVkIHdpdGggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1JhdyB0cmFuc2FjdGlvbiBkYXRhOicsIHRyYW5zYWN0aW9ucyk7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgYXJyYXlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBkaWQgbm90IHJldHVybiBhbiBhcnJheTonLCB0cmFuc2FjdGlvbnMpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIE1hcCBhbmQgdmFsaWRhdGUgdGhlIGRhdGFcclxuICAgIGNvbnN0IHZhbGlkYXRlZFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoaXRlbSA9PiAoe1xyXG4gICAgICBpZDogTnVtYmVyKGl0ZW0uaWQgfHwgMCksXHJcbiAgICAgIGNhcmROdW1iZXI6IFN0cmluZyhpdGVtLmNhcmROdW1iZXIgfHwgJycpLFxyXG4gICAgICBjYXJkVHlwZTogU3RyaW5nKGl0ZW0uY2FyZFR5cGUgfHwgJycpLFxyXG4gICAgICBhbW91bnQ6IE51bWJlcihpdGVtLmFtb3VudCB8fCAwKSxcclxuICAgICAgdHJhbnNhY3Rpb25UaW1lU3RhbXA6IFN0cmluZyhpdGVtLnRyYW5zYWN0aW9uVGltZVN0YW1wIHx8ICcnKSxcclxuICAgICAgdHJhbnNhY3Rpb25TdGF0dXM6IE51bWJlcihpdGVtLnRyYW5zYWN0aW9uU3RhdHVzIHx8IDApLFxyXG4gICAgICB0cmFuc2FjdGlvblByb2Nlc3NlZFRpbWVTdGFtcDogU3RyaW5nKGl0ZW0udHJhbnNhY3Rpb25Qcm9jZXNzZWRUaW1lU3RhbXAgfHwgJycpXHJcbiAgICB9KSk7XHJcbiAgICBcclxuICAgIHJldHVybiB2YWxpZGF0ZWRUcmFuc2FjdGlvbnM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2Nlc3NvciBkYXRhOicsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJlamVjdGVkVHJhbnNhY3Rpb25zQ291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYENhbGxpbmcgQVBJIGZvciByZWplY3RlZCBjb3VudDogJHtCQVNFX1VSTH0vUHJvY2Vzc29yQ291bnQ/c3RhdHVzPVJlamVjdGVkYCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9Qcm9jZXNzb3JDb3VudD9zdGF0dXM9UmVqZWN0ZWRgLCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbigpfWBcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVzcG9uZGVkIHdpdGggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1JlamVjdGVkIHRyYW5zYWN0aW9ucyBjb3VudDonLCBjb3VudCk7XHJcbiAgICBcclxuICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwoTnVtYmVyKGNvdW50KSAvIElURU1TX1BFUl9QQUdFKTsgXHJcbiAgICBjb25zb2xlLmxvZyhgVG90YWwgcGFnZXMgZm9yIHJlamVjdGVkIHRyYW5zYWN0aW9uczogJHt0b3RhbFBhZ2VzfWApO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdG90YWxQYWdlcztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVqZWN0ZWQgdHJhbnNhY3Rpb25zIGNvdW50OicsIGVycm9yKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUmVwb3J0aW5nQnlDYXJkKCk6IFByb21pc2U8Q2FyZFJlcG9ydFtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGBDYWxsaW5nIEFQSTogJHtCQVNFX1VSTH0vUmVwb3J0aW5nQnlDYXJkYCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9SZXBvcnRpbmdCeUNhcmRgLCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbigpfWBcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVzcG9uZGVkIHdpdGggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnUmF3IEFQSSByZXNwb25zZTonLCByZXN1bHRzKTtcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBhcnJheVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBkaWQgbm90IHJldHVybiBhbiBhcnJheTonLCByZXN1bHRzKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBNYXAgYW5kIHZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZVxyXG4gICAgY29uc3QgY2FyZFJlcG9ydHMgPSByZXN1bHRzLm1hcChpdGVtID0+ICh7XHJcbiAgICAgIGNhcmROdW1iZXI6IFN0cmluZyhpdGVtLmNhcmROdW1iZXIgfHwgJycpLFxyXG4gICAgICB0cmFuc2FjdGlvbkNvdW50OiBOdW1iZXIoaXRlbS50cmFuc2FjdGlvbkNvdW50IHx8IDApLFxyXG4gICAgICB0b3RhbEFtb3VudDogTnVtYmVyKGl0ZW0udG90YWxBbW91bnQgfHwgMClcclxuICAgIH0pKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGNhcmRSZXBvcnRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZXBvcnRpbmcgYnkgY2FyZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBvcnRpbmdCeUNhcmRUeXBlKCk6IFByb21pc2U8Q2FyZFR5cGVSZXBvcnRbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgQ2FsbGluZyBBUEk6ICR7QkFTRV9VUkx9L1JlcG9ydGluZ0J5Q2FyZFR5cGVgKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L1JlcG9ydGluZ0J5Q2FyZFR5cGVgKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXNwb25kZWQgd2l0aCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1JhdyBBUEkgcmVzcG9uc2U6JywgcmVzdWx0cyk7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgYXJyYXlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgZGlkIG5vdCByZXR1cm4gYW4gYXJyYXk6JywgcmVzdWx0cyk7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTWFwIGFuZCB2YWxpZGF0ZSB0aGUgZGF0YVxyXG4gICAgY29uc3QgY2FyZFR5cGVSZXBvcnRzID0gcmVzdWx0cy5tYXAoaXRlbSA9PiAoe1xyXG4gICAgICBjYXJkVHlwZTogU3RyaW5nKGl0ZW0uY2FyZFR5cGUgfHwgJycpLFxyXG4gICAgICB0cmFuc2FjdGlvbkNvdW50OiBOdW1iZXIoaXRlbS50cmFuc2FjdGlvbkNvdW50IHx8IDApLFxyXG4gICAgICB0b3RhbEFtb3VudDogTnVtYmVyKGl0ZW0udG90YWxBbW91bnQgfHwgMClcclxuICAgIH0pKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGNhcmRUeXBlUmVwb3J0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVwb3J0aW5nIGJ5IGNhcmQgdHlwZTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBvcnRpbmdCeURheSgpOiBQcm9taXNlPERhaWx5UmVwb3J0W10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYENhbGxpbmcgQVBJOiAke0JBU0VfVVJMfS9SZXBvcnRpbmdCeURheWApO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vUmVwb3J0aW5nQnlEYXlgKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXNwb25kZWQgd2l0aCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1JhdyBBUEkgcmVzcG9uc2U6JywgcmVzdWx0cyk7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgYXJyYXlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgZGlkIG5vdCByZXR1cm4gYW4gYXJyYXk6JywgcmVzdWx0cyk7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTWFwIGFuZCB2YWxpZGF0ZSB0aGUgZGF0YVxyXG4gICAgY29uc3QgZGFpbHlSZXBvcnRzID0gcmVzdWx0cy5tYXAoaXRlbSA9PiAoe1xyXG4gICAgICB0cmFuc2FjdGlvbkRhdGU6IFN0cmluZyhpdGVtLnRyYW5zYWN0aW9uRGF0ZSB8fCAnJyksXHJcbiAgICAgIHRyYW5zYWN0aW9uQ291bnQ6IE51bWJlcihpdGVtLnRyYW5zYWN0aW9uQ291bnQgfHwgMCksXHJcbiAgICAgIHRvdGFsQW1vdW50OiBOdW1iZXIoaXRlbS50b3RhbEFtb3VudCB8fCAwKVxyXG4gICAgfSkpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZGFpbHlSZXBvcnRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZXBvcnRpbmcgYnkgZGF5OicsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJtaXRQcm9jZXNzb3JEYXRhKHR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICB0cnkge1xyXG4gICAgLy8gQWx3YXlzIHVzZSB1cHBlcmNhc2UgZm9yIGZvcm1hdCB0eXBlIGFzIGV4cGVjdGVkIGJ5IEFQSVxyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnRvVXBwZXJDYXNlKCk7ICAgIFxyXG4gICAgY29uc29sZS5sb2coYFN1Ym1pdHRpbmcgJHtkYXRhVHlwZX0gZGF0YSB0byAke0JBU0VfVVJMfS9Qcm9jZXNzb3JgKTtcclxuICAgIGNvbnNvbGUubG9nKGBJbnB1dCBmb3JtYXQgdHlwZTogJHt0eXBlfSwgbm9ybWFsaXplZCB0bzogJHtkYXRhVHlwZX1gKTtcclxuXHJcbiAgICAvLyBJbXBvcnRhbnQ6IFRoZSBBUEkgZXhwZWN0cyBcInR5cGVcIiBhcyB0aGUgcHJvcGVydHkgbmFtZSwgbm90IFwiZGF0YVR5cGVcIlxyXG4gICAgY29uc3QgYnVsa1RyYW5zYWN0aW9uID0ge1xyXG4gICAgICAgIHR5cGU6IGRhdGFUeXBlLFxyXG4gICAgICAgIGRhdGE6IGRhdGFcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHBheWxvYWQgc3RydWN0dXJlOicsIHsgXHJcbiAgICAgIHR5cGU6IGJ1bGtUcmFuc2FjdGlvbi50eXBlLCBcclxuICAgICAgZGF0YUxlbmd0aDogYnVsa1RyYW5zYWN0aW9uLmRhdGEubGVuZ3RoLFxyXG4gICAgICBkYXRhU2FtcGxlOiBidWxrVHJhbnNhY3Rpb24uZGF0YS5zdWJzdHJpbmcoMCwgNTApICsgJy4uLidcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L1Byb2Nlc3Nvci9idWxrYCwgXHJcbiAgICAgICAgeyBcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYnVsa1RyYW5zYWN0aW9uKVxyXG4gICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQVBJIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBBUEkgRXJyb3IgKCR7cmVzcG9uc2Uuc3RhdHVzfSk6YCwgZXJyb3JUZXh0KTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0IHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiAnRGF0YSBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JyB9KSk7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJIFJlc3BvbnNlOicsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBwcm9jZXNzb3IgZGF0YTonLCBlcnJvcik7ICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcclxuICAgIG1vbnRoOiAnMi1kaWdpdCcsXHJcbiAgICBkYXk6ICcyLWRpZ2l0JyxcclxuICAgIHllYXI6ICdudW1lcmljJ1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWUoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcclxuICAgIG1vbnRoOiAnMi1kaWdpdCcsXHJcbiAgICBkYXk6ICcyLWRpZ2l0JyxcclxuICAgIHllYXI6ICdudW1lcmljJ1xyXG4gIH0pICsgJyAnICsgZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywge1xyXG4gICAgaG91cjogJzItZGlnaXQnLFxyXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICBzZWNvbmQ6ICcyLWRpZ2l0JyxcclxuICAgIGhvdXIxMjogZmFsc2VcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KGFtb3VudDogbnVtYmVyKTogc3RyaW5nIHtcclxuICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KCdlbi1VUycsIHtcclxuICAgIHN0eWxlOiAnY3VycmVuY3knLFxyXG4gICAgY3VycmVuY3k6ICdVU0QnLFxyXG4gICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxyXG4gICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyXHJcbiAgfSkuZm9ybWF0KGFtb3VudCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBUcmFuc2FjdGlvblN0YXR1cyhzdGF0dXM6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgIGNhc2UgMTpcclxuICAgICAgcmV0dXJuICdBY2NlcHRlZCc7XHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIHJldHVybiAnUmVqZWN0ZWQnO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICdVbmtub3duJztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCZWFyZXJUb2tlbigpOiBzdHJpbmcge1xyXG4gIC8vIFJldHVybiB0aGUgY2FjaGVkIHRva2VuIG9yIGdldCBhIG5ldyBvbmUgaWYgZXhwaXJlZCBvciBtaXNzaW5nLCBiYXNlZCBvbiBjcmVkZW50aWFscy4gIFxyXG4gIC8vIFRoaXMgd2lsbCBuZWVkIHRvIGJlIGNoYW5nZWQgd2l0aCByZWFsIGF1dGhlbnRpY2F0aW9uIGxvZ2ljLlxyXG4gIHJldHVybiBCRUFSRVJfVE9LRU47XHJcbn1cclxuIl0sIm5hbWVzIjpbIkJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCIsIklURU1TX1BFUl9QQUdFIiwiQkVBUkVSX1RPS0VOIiwiZmV0Y2hQcm9jZXNzb3JDb3VudCIsImNhcmROdW1iZXIiLCJzdGF0dXMiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImdldEJlYXJlclRva2VuIiwiY291bnQiLCJqc29uIiwidG90YWxQYWdlcyIsIk1hdGgiLCJjZWlsIiwiTnVtYmVyIiwiZXJyb3IiLCJjb25zb2xlIiwiZmV0Y2hQcm9jZXNzb3JEYXRhIiwicGFnZU51bSIsImxvZyIsIm9rIiwiRXJyb3IiLCJ0cmFuc2FjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxpZGF0ZWRUcmFuc2FjdGlvbnMiLCJtYXAiLCJpdGVtIiwiaWQiLCJTdHJpbmciLCJjYXJkVHlwZSIsImFtb3VudCIsInRyYW5zYWN0aW9uVGltZVN0YW1wIiwidHJhbnNhY3Rpb25TdGF0dXMiLCJ0cmFuc2FjdGlvblByb2Nlc3NlZFRpbWVTdGFtcCIsImZldGNoUmVqZWN0ZWRUcmFuc2FjdGlvbnNDb3VudCIsImZldGNoUmVwb3J0aW5nQnlDYXJkIiwicmVzdWx0cyIsImNhcmRSZXBvcnRzIiwidHJhbnNhY3Rpb25Db3VudCIsInRvdGFsQW1vdW50IiwiZmV0Y2hSZXBvcnRpbmdCeUNhcmRUeXBlIiwiY2FyZFR5cGVSZXBvcnRzIiwiZmV0Y2hSZXBvcnRpbmdCeURheSIsImRhaWx5UmVwb3J0cyIsInRyYW5zYWN0aW9uRGF0ZSIsInN1Ym1pdFByb2Nlc3NvckRhdGEiLCJ0eXBlIiwiZGF0YSIsImRhdGFUeXBlIiwidG9VcHBlckNhc2UiLCJidWxrVHJhbnNhY3Rpb24iLCJkYXRhTGVuZ3RoIiwibGVuZ3RoIiwiZGF0YVNhbXBsZSIsInN1YnN0cmluZyIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1c1RleHQiLCJyZXN1bHQiLCJjYXRjaCIsIm1lc3NhZ2UiLCJmb3JtYXREYXRlIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwibW9udGgiLCJkYXkiLCJ5ZWFyIiwiZm9ybWF0RGF0ZVRpbWUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiaG91cjEyIiwiZm9ybWF0Q3VycmVuY3kiLCJJbnRsIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJjdXJyZW5jeSIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImZvcm1hdCIsIm1hcFRyYW5zYWN0aW9uU3RhdHVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});