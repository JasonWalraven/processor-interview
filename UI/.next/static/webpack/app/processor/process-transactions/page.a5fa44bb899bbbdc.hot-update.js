"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/processor/process-transactions/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProcessorCount: () => (/* binding */ fetchProcessorCount),\n/* harmony export */   fetchProcessorData: () => (/* binding */ fetchProcessorData),\n/* harmony export */   fetchRejectedTransactionsCount: () => (/* binding */ fetchRejectedTransactionsCount),\n/* harmony export */   fetchReportingByCard: () => (/* binding */ fetchReportingByCard),\n/* harmony export */   fetchReportingByCardType: () => (/* binding */ fetchReportingByCardType),\n/* harmony export */   fetchReportingByDay: () => (/* binding */ fetchReportingByDay),\n/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatDateTime: () => (/* binding */ formatDateTime),\n/* harmony export */   mapTransactionStatus: () => (/* binding */ mapTransactionStatus),\n/* harmony export */   submitProcessorData: () => (/* binding */ submitProcessorData)\n/* harmony export */ });\n// Use environment variable with fallback\nconst BASE_URL = \"https://localhost:7039\" || 0;\nconst ITEMS_PER_PAGE = 25;\nconst BEARER_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODUxNDA5ODQsImlhdCI6MTQ4NTEzNzM4NCwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiIyOWFjMGMxOC0wYjRhLTQyY2YtODJmYy0wM2Q1NzAzMThhMWQiLCJhcHBsaWNhdGlvbklkIjoiNzkxMDM3MzQtOTdhYi00ZDFhLWFmMzctZTAwNmQwNWQyOTUyIiwicm9sZXMiOltdfQ.Mp0Pcwsz5VECK11Kf2ZZNF_SMKu5CgBeLN9ZOP04kZo';\nasync function fetchProcessorCount(cardNumber, status) {\n    try {\n        const response = await fetch(\"\".concat(BASE_URL, \"/ProcessorCount?cardNumber=\").concat(cardNumber, \"&status=\").concat(status));\n        const count = await response.json();\n        const totalPages = Math.ceil(Number(count) / ITEMS_PER_PAGE);\n        return totalPages;\n    } catch (error) {\n        console.error('Error fetching processor count:', error);\n        return 0;\n    }\n}\nasync function fetchProcessorData(pageNum, cardNumber, status) {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/Processor?pageNumber=\").concat(pageNum, \"&cardNumber=\").concat(cardNumber || '', \"&status=\").concat(status || ''));\n        const response = await fetch(\"\".concat(BASE_URL, \"/Processor?pageNumber=\").concat(pageNum, \"&cardNumber=\").concat(cardNumber || '', \"&status=\").concat(status || ''));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const transactions = await response.json();\n        console.log('Raw transaction data:', transactions);\n        // Ensure we have a valid array\n        if (!Array.isArray(transactions)) {\n            console.error('API did not return an array:', transactions);\n            return [];\n        }\n        // Map and validate the data\n        const validatedTransactions = transactions.map((item)=>({\n                id: Number(item.id || 0),\n                cardNumber: String(item.cardNumber || ''),\n                cardType: String(item.cardType || ''),\n                amount: Number(item.amount || 0),\n                transactionTimeStamp: String(item.transactionTimeStamp || ''),\n                transactionStatus: Number(item.transactionStatus || 0),\n                transactionProcessedTimeStamp: String(item.transactionProcessedTimeStamp || '')\n            }));\n        return validatedTransactions;\n    } catch (error) {\n        console.error('Error fetching processor data:', error);\n        return [];\n    }\n}\nasync function fetchRejectedTransactionsCount() {\n    try {\n        console.log(\"Calling API for rejected count: \".concat(BASE_URL, \"/ProcessorCount?status=Rejected\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ProcessorCount?status=Rejected\"));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const count = await response.json();\n        console.log('Rejected transactions count:', count);\n        const totalPages = Math.ceil(Number(count) / ITEMS_PER_PAGE);\n        console.log(\"Total pages for rejected transactions: \".concat(totalPages));\n        return totalPages;\n    } catch (error) {\n        console.error('Error fetching rejected transactions count:', error);\n        return 0;\n    }\n}\nasync function fetchReportingByCard() {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/ReportingByCard\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ReportingByCard\"));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const results = await response.json();\n        console.log('Raw API response:', results);\n        // Ensure we have a valid array\n        if (!Array.isArray(results)) {\n            console.error('API did not return an array:', results);\n            return [];\n        }\n        // Map and validate the data structure\n        const cardReports = results.map((item)=>({\n                cardNumber: String(item.cardNumber || ''),\n                transactionCount: Number(item.transactionCount || 0),\n                totalAmount: Number(item.totalAmount || 0)\n            }));\n        return cardReports;\n    } catch (error) {\n        console.error('Error fetching reporting by card:', error);\n        return [];\n    }\n}\nasync function fetchReportingByCardType() {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/ReportingByCardType\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ReportingByCardType\"));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const results = await response.json();\n        console.log('Raw API response:', results);\n        // Ensure we have a valid array\n        if (!Array.isArray(results)) {\n            console.error('API did not return an array:', results);\n            return [];\n        }\n        // Map and validate the data\n        const cardTypeReports = results.map((item)=>({\n                cardType: String(item.cardType || ''),\n                transactionCount: Number(item.transactionCount || 0),\n                totalAmount: Number(item.totalAmount || 0)\n            }));\n        return cardTypeReports;\n    } catch (error) {\n        console.error('Error fetching reporting by card type:', error);\n        return [];\n    }\n}\nasync function fetchReportingByDay() {\n    try {\n        console.log(\"Calling API: \".concat(BASE_URL, \"/ReportingByDay\"));\n        const response = await fetch(\"\".concat(BASE_URL, \"/ReportingByDay\"));\n        if (!response.ok) {\n            throw new Error(\"API responded with status: \".concat(response.status));\n        }\n        const results = await response.json();\n        console.log('Raw API response:', results);\n        // Ensure we have a valid array\n        if (!Array.isArray(results)) {\n            console.error('API did not return an array:', results);\n            return [];\n        }\n        // Map and validate the data\n        const dailyReports = results.map((item)=>({\n                transactionDate: String(item.transactionDate || ''),\n                transactionCount: Number(item.transactionCount || 0),\n                totalAmount: Number(item.totalAmount || 0)\n            }));\n        return dailyReports;\n    } catch (error) {\n        console.error('Error fetching reporting by day:', error);\n        return [];\n    }\n}\nasync function submitProcessorData(type, data) {\n    try {\n        // Always use uppercase for format type as expected by API\n        const dataType = type.toUpperCase();\n        console.log(\"Submitting \".concat(dataType, \" data to \").concat(BASE_URL, \"/Processor\"));\n        console.log(\"Input format type: \".concat(type, \", normalized to: \").concat(dataType));\n        // Important: The API expects \"type\" as the property name, not \"dataType\"\n        const bulkTransaction = {\n            type: dataType,\n            data: data\n        };\n        console.log('Request payload structure:', {\n            type: bulkTransaction.type,\n            dataLength: bulkTransaction.data.length,\n            dataSample: bulkTransaction.data.substring(0, 50) + '...'\n        });\n        const response = await fetch(\"\".concat(BASE_URL, \"/Processor/bulk\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(bulkTransaction)\n        });\n        console.log('API response status:', response.status);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"API Error (\".concat(response.status, \"):\"), errorText);\n            throw new Error(\"Server returned \".concat(response.status, \": \").concat(errorText || response.statusText));\n        }\n        const result = await response.json().catch(()=>({\n                message: 'Data submitted successfully'\n            }));\n        console.log('API Response:', result);\n        return result;\n    } catch (error) {\n        console.error('Error submitting processor data:', error);\n        throw error;\n    }\n}\nfunction formatDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n        month: '2-digit',\n        day: '2-digit',\n        year: 'numeric'\n    });\n}\nfunction formatDateTime(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n        month: '2-digit',\n        day: '2-digit',\n        year: 'numeric'\n    }) + ' ' + date.toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false\n    });\n}\nfunction formatCurrency(amount) {\n    return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD',\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount);\n}\nfunction mapTransactionStatus(status) {\n    switch(status){\n        case 1:\n            return 'Accepted';\n        case 2:\n            return 'Rejected';\n        default:\n            return 'Unknown';\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d1xccHJvY2Vzc29yLWludGVydmlld1xcVUlcXGxpYlxcYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcbmltcG9ydCB7IENhcmRSZXBvcnQsIENhcmRUeXBlUmVwb3J0LCBEYWlseVJlcG9ydCwgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbi8vIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIGZhbGxiYWNrXHJcbmNvbnN0IEJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIHx8ICdodHRwczovL2xvY2FsaG9zdDo3MDM5JztcclxuY29uc3QgSVRFTVNfUEVSX1BBR0UgPSAyNTtcclxuY29uc3QgQkVBUkVSX1RPS0VOID0gJ2V5SmhiR2NpT2lKSVV6STFOaUlzSW5SNWNDSTZJa3BYVkNKOS5leUpsZUhBaU9qRTBPRFV4TkRBNU9EUXNJbWxoZENJNk1UUTROVEV6TnpNNE5Dd2lhWE56SWpvaVlXTnRaUzVqYjIwaUxDSnpkV0lpT2lJeU9XRmpNR014T0Mwd1lqUmhMVFF5WTJZdE9ESm1ZeTB3TTJRMU56QXpNVGhoTVdRaUxDSmhjSEJzYVdOaGRHbHZia2xrSWpvaU56a3hNRE0zTXpRdE9UZGhZaTAwWkRGaExXRm1NemN0WlRBd05tUXdOV1F5T1RVeUlpd2ljbTlzWlhNaU9sdGRmUS5NcDBQY3dzejVWRUNLMTFLZjJaWk5GX1NNS3U1Q2dCZUxOOVpPUDA0a1pvJztcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByb2Nlc3NvckNvdW50KGNhcmROdW1iZXI/OiBzdHJpbmcsIHN0YXR1cz86IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgdHJ5IHsgICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9Qcm9jZXNzb3JDb3VudD9jYXJkTnVtYmVyPSR7Y2FyZE51bWJlcn0mc3RhdHVzPSR7c3RhdHVzfWApO1xyXG4gICAgY29uc3QgY291bnQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgY29uc3QgIHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwoTnVtYmVyKGNvdW50KSAvIElURU1TX1BFUl9QQUdFKTsgXHJcblxyXG4gICAgcmV0dXJuIHRvdGFsUGFnZXM7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9jZXNzb3IgY291bnQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcm9jZXNzb3JEYXRhKHBhZ2VOdW06IG51bWJlciwgY2FyZE51bWJlcj86IHN0cmluZywgc3RhdHVzPzogc3RyaW5nKTogUHJvbWlzZTxUcmFuc2FjdGlvbltdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGBDYWxsaW5nIEFQSTogJHtCQVNFX1VSTH0vUHJvY2Vzc29yP3BhZ2VOdW1iZXI9JHtwYWdlTnVtfSZjYXJkTnVtYmVyPSR7Y2FyZE51bWJlciB8fCAnJ30mc3RhdHVzPSR7c3RhdHVzIHx8ICcnfWApO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vUHJvY2Vzc29yP3BhZ2VOdW1iZXI9JHtwYWdlTnVtfSZjYXJkTnVtYmVyPSR7Y2FyZE51bWJlciB8fCAnJ30mc3RhdHVzPSR7c3RhdHVzIHx8ICcnfWApO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIHJlc3BvbmRlZCB3aXRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnNvbGUubG9nKCdSYXcgdHJhbnNhY3Rpb24gZGF0YTonLCB0cmFuc2FjdGlvbnMpO1xyXG4gICAgXHJcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIGFycmF5XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgZGlkIG5vdCByZXR1cm4gYW4gYXJyYXk6JywgdHJhbnNhY3Rpb25zKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBNYXAgYW5kIHZhbGlkYXRlIHRoZSBkYXRhXHJcbiAgICBjb25zdCB2YWxpZGF0ZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKGl0ZW0gPT4gKHtcclxuICAgICAgaWQ6IE51bWJlcihpdGVtLmlkIHx8IDApLFxyXG4gICAgICBjYXJkTnVtYmVyOiBTdHJpbmcoaXRlbS5jYXJkTnVtYmVyIHx8ICcnKSxcclxuICAgICAgY2FyZFR5cGU6IFN0cmluZyhpdGVtLmNhcmRUeXBlIHx8ICcnKSxcclxuICAgICAgYW1vdW50OiBOdW1iZXIoaXRlbS5hbW91bnQgfHwgMCksXHJcbiAgICAgIHRyYW5zYWN0aW9uVGltZVN0YW1wOiBTdHJpbmcoaXRlbS50cmFuc2FjdGlvblRpbWVTdGFtcCB8fCAnJyksXHJcbiAgICAgIHRyYW5zYWN0aW9uU3RhdHVzOiBOdW1iZXIoaXRlbS50cmFuc2FjdGlvblN0YXR1cyB8fCAwKSxcclxuICAgICAgdHJhbnNhY3Rpb25Qcm9jZXNzZWRUaW1lU3RhbXA6IFN0cmluZyhpdGVtLnRyYW5zYWN0aW9uUHJvY2Vzc2VkVGltZVN0YW1wIHx8ICcnKVxyXG4gICAgfSkpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdmFsaWRhdGVkVHJhbnNhY3Rpb25zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9jZXNzb3IgZGF0YTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWplY3RlZFRyYW5zYWN0aW9uc0NvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGBDYWxsaW5nIEFQSSBmb3IgcmVqZWN0ZWQgY291bnQ6ICR7QkFTRV9VUkx9L1Byb2Nlc3NvckNvdW50P3N0YXR1cz1SZWplY3RlZGApO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vUHJvY2Vzc29yQ291bnQ/c3RhdHVzPVJlamVjdGVkYCk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVzcG9uZGVkIHdpdGggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgY291bnQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnUmVqZWN0ZWQgdHJhbnNhY3Rpb25zIGNvdW50OicsIGNvdW50KTtcclxuICAgIFxyXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbChOdW1iZXIoY291bnQpIC8gSVRFTVNfUEVSX1BBR0UpOyBcclxuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBwYWdlcyBmb3IgcmVqZWN0ZWQgdHJhbnNhY3Rpb25zOiAke3RvdGFsUGFnZXN9YCk7XHJcbiAgICBcclxuICAgIHJldHVybiB0b3RhbFBhZ2VzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWplY3RlZCB0cmFuc2FjdGlvbnMgY291bnQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBvcnRpbmdCeUNhcmQoKTogUHJvbWlzZTxDYXJkUmVwb3J0W10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYENhbGxpbmcgQVBJOiAke0JBU0VfVVJMfS9SZXBvcnRpbmdCeUNhcmRgKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L1JlcG9ydGluZ0J5Q2FyZGApO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIHJlc3BvbmRlZCB3aXRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnUmF3IEFQSSByZXNwb25zZTonLCByZXN1bHRzKTtcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBhcnJheVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBkaWQgbm90IHJldHVybiBhbiBhcnJheTonLCByZXN1bHRzKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBNYXAgYW5kIHZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZVxyXG4gICAgY29uc3QgY2FyZFJlcG9ydHMgPSByZXN1bHRzLm1hcChpdGVtID0+ICh7XHJcbiAgICAgIGNhcmROdW1iZXI6IFN0cmluZyhpdGVtLmNhcmROdW1iZXIgfHwgJycpLFxyXG4gICAgICB0cmFuc2FjdGlvbkNvdW50OiBOdW1iZXIoaXRlbS50cmFuc2FjdGlvbkNvdW50IHx8IDApLFxyXG4gICAgICB0b3RhbEFtb3VudDogTnVtYmVyKGl0ZW0udG90YWxBbW91bnQgfHwgMClcclxuICAgIH0pKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGNhcmRSZXBvcnRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZXBvcnRpbmcgYnkgY2FyZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBvcnRpbmdCeUNhcmRUeXBlKCk6IFByb21pc2U8Q2FyZFR5cGVSZXBvcnRbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgQ2FsbGluZyBBUEk6ICR7QkFTRV9VUkx9L1JlcG9ydGluZ0J5Q2FyZFR5cGVgKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L1JlcG9ydGluZ0J5Q2FyZFR5cGVgKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXNwb25kZWQgd2l0aCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1JhdyBBUEkgcmVzcG9uc2U6JywgcmVzdWx0cyk7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgYXJyYXlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgZGlkIG5vdCByZXR1cm4gYW4gYXJyYXk6JywgcmVzdWx0cyk7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTWFwIGFuZCB2YWxpZGF0ZSB0aGUgZGF0YVxyXG4gICAgY29uc3QgY2FyZFR5cGVSZXBvcnRzID0gcmVzdWx0cy5tYXAoaXRlbSA9PiAoe1xyXG4gICAgICBjYXJkVHlwZTogU3RyaW5nKGl0ZW0uY2FyZFR5cGUgfHwgJycpLFxyXG4gICAgICB0cmFuc2FjdGlvbkNvdW50OiBOdW1iZXIoaXRlbS50cmFuc2FjdGlvbkNvdW50IHx8IDApLFxyXG4gICAgICB0b3RhbEFtb3VudDogTnVtYmVyKGl0ZW0udG90YWxBbW91bnQgfHwgMClcclxuICAgIH0pKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGNhcmRUeXBlUmVwb3J0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVwb3J0aW5nIGJ5IGNhcmQgdHlwZTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBvcnRpbmdCeURheSgpOiBQcm9taXNlPERhaWx5UmVwb3J0W10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYENhbGxpbmcgQVBJOiAke0JBU0VfVVJMfS9SZXBvcnRpbmdCeURheWApO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vUmVwb3J0aW5nQnlEYXlgKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXNwb25kZWQgd2l0aCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1JhdyBBUEkgcmVzcG9uc2U6JywgcmVzdWx0cyk7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgYXJyYXlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgZGlkIG5vdCByZXR1cm4gYW4gYXJyYXk6JywgcmVzdWx0cyk7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTWFwIGFuZCB2YWxpZGF0ZSB0aGUgZGF0YVxyXG4gICAgY29uc3QgZGFpbHlSZXBvcnRzID0gcmVzdWx0cy5tYXAoaXRlbSA9PiAoe1xyXG4gICAgICB0cmFuc2FjdGlvbkRhdGU6IFN0cmluZyhpdGVtLnRyYW5zYWN0aW9uRGF0ZSB8fCAnJyksXHJcbiAgICAgIHRyYW5zYWN0aW9uQ291bnQ6IE51bWJlcihpdGVtLnRyYW5zYWN0aW9uQ291bnQgfHwgMCksXHJcbiAgICAgIHRvdGFsQW1vdW50OiBOdW1iZXIoaXRlbS50b3RhbEFtb3VudCB8fCAwKVxyXG4gICAgfSkpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZGFpbHlSZXBvcnRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZXBvcnRpbmcgYnkgZGF5OicsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJtaXRQcm9jZXNzb3JEYXRhKHR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICB0cnkge1xyXG4gICAgLy8gQWx3YXlzIHVzZSB1cHBlcmNhc2UgZm9yIGZvcm1hdCB0eXBlIGFzIGV4cGVjdGVkIGJ5IEFQSVxyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnRvVXBwZXJDYXNlKCk7ICAgIFxyXG4gICAgY29uc29sZS5sb2coYFN1Ym1pdHRpbmcgJHtkYXRhVHlwZX0gZGF0YSB0byAke0JBU0VfVVJMfS9Qcm9jZXNzb3JgKTtcclxuICAgIGNvbnNvbGUubG9nKGBJbnB1dCBmb3JtYXQgdHlwZTogJHt0eXBlfSwgbm9ybWFsaXplZCB0bzogJHtkYXRhVHlwZX1gKTtcclxuXHJcbiAgICAvLyBJbXBvcnRhbnQ6IFRoZSBBUEkgZXhwZWN0cyBcInR5cGVcIiBhcyB0aGUgcHJvcGVydHkgbmFtZSwgbm90IFwiZGF0YVR5cGVcIlxyXG4gICAgY29uc3QgYnVsa1RyYW5zYWN0aW9uID0ge1xyXG4gICAgICAgIHR5cGU6IGRhdGFUeXBlLFxyXG4gICAgICAgIGRhdGE6IGRhdGFcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHBheWxvYWQgc3RydWN0dXJlOicsIHsgXHJcbiAgICAgIHR5cGU6IGJ1bGtUcmFuc2FjdGlvbi50eXBlLCBcclxuICAgICAgZGF0YUxlbmd0aDogYnVsa1RyYW5zYWN0aW9uLmRhdGEubGVuZ3RoLFxyXG4gICAgICBkYXRhU2FtcGxlOiBidWxrVHJhbnNhY3Rpb24uZGF0YS5zdWJzdHJpbmcoMCwgNTApICsgJy4uLidcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L1Byb2Nlc3Nvci9idWxrYCwgXHJcbiAgICAgICAgeyBcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYnVsa1RyYW5zYWN0aW9uKVxyXG4gICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQVBJIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBBUEkgRXJyb3IgKCR7cmVzcG9uc2Uuc3RhdHVzfSk6YCwgZXJyb3JUZXh0KTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0IHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiAnRGF0YSBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JyB9KSk7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJIFJlc3BvbnNlOicsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBwcm9jZXNzb3IgZGF0YTonLCBlcnJvcik7ICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcclxuICAgIG1vbnRoOiAnMi1kaWdpdCcsXHJcbiAgICBkYXk6ICcyLWRpZ2l0JyxcclxuICAgIHllYXI6ICdudW1lcmljJ1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWUoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcclxuICAgIG1vbnRoOiAnMi1kaWdpdCcsXHJcbiAgICBkYXk6ICcyLWRpZ2l0JyxcclxuICAgIHllYXI6ICdudW1lcmljJ1xyXG4gIH0pICsgJyAnICsgZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywge1xyXG4gICAgaG91cjogJzItZGlnaXQnLFxyXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICBzZWNvbmQ6ICcyLWRpZ2l0JyxcclxuICAgIGhvdXIxMjogZmFsc2VcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KGFtb3VudDogbnVtYmVyKTogc3RyaW5nIHtcclxuICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KCdlbi1VUycsIHtcclxuICAgIHN0eWxlOiAnY3VycmVuY3knLFxyXG4gICAgY3VycmVuY3k6ICdVU0QnLFxyXG4gICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxyXG4gICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyXHJcbiAgfSkuZm9ybWF0KGFtb3VudCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBUcmFuc2FjdGlvblN0YXR1cyhzdGF0dXM6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgIGNhc2UgMTpcclxuICAgICAgcmV0dXJuICdBY2NlcHRlZCc7XHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIHJldHVybiAnUmVqZWN0ZWQnO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICdVbmtub3duJztcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIkJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCIsIklURU1TX1BFUl9QQUdFIiwiQkVBUkVSX1RPS0VOIiwiZmV0Y2hQcm9jZXNzb3JDb3VudCIsImNhcmROdW1iZXIiLCJzdGF0dXMiLCJyZXNwb25zZSIsImZldGNoIiwiY291bnQiLCJqc29uIiwidG90YWxQYWdlcyIsIk1hdGgiLCJjZWlsIiwiTnVtYmVyIiwiZXJyb3IiLCJjb25zb2xlIiwiZmV0Y2hQcm9jZXNzb3JEYXRhIiwicGFnZU51bSIsImxvZyIsIm9rIiwiRXJyb3IiLCJ0cmFuc2FjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxpZGF0ZWRUcmFuc2FjdGlvbnMiLCJtYXAiLCJpdGVtIiwiaWQiLCJTdHJpbmciLCJjYXJkVHlwZSIsImFtb3VudCIsInRyYW5zYWN0aW9uVGltZVN0YW1wIiwidHJhbnNhY3Rpb25TdGF0dXMiLCJ0cmFuc2FjdGlvblByb2Nlc3NlZFRpbWVTdGFtcCIsImZldGNoUmVqZWN0ZWRUcmFuc2FjdGlvbnNDb3VudCIsImZldGNoUmVwb3J0aW5nQnlDYXJkIiwicmVzdWx0cyIsImNhcmRSZXBvcnRzIiwidHJhbnNhY3Rpb25Db3VudCIsInRvdGFsQW1vdW50IiwiZmV0Y2hSZXBvcnRpbmdCeUNhcmRUeXBlIiwiY2FyZFR5cGVSZXBvcnRzIiwiZmV0Y2hSZXBvcnRpbmdCeURheSIsImRhaWx5UmVwb3J0cyIsInRyYW5zYWN0aW9uRGF0ZSIsInN1Ym1pdFByb2Nlc3NvckRhdGEiLCJ0eXBlIiwiZGF0YSIsImRhdGFUeXBlIiwidG9VcHBlckNhc2UiLCJidWxrVHJhbnNhY3Rpb24iLCJkYXRhTGVuZ3RoIiwibGVuZ3RoIiwiZGF0YVNhbXBsZSIsInN1YnN0cmluZyIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yVGV4dCIsInRleHQiLCJzdGF0dXNUZXh0IiwicmVzdWx0IiwiY2F0Y2giLCJtZXNzYWdlIiwiZm9ybWF0RGF0ZSIsImRhdGVTdHJpbmciLCJkYXRlIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIm1vbnRoIiwiZGF5IiwieWVhciIsImZvcm1hdERhdGVUaW1lIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsImhvdXIxMiIsImZvcm1hdEN1cnJlbmN5IiwiSW50bCIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiY3VycmVuY3kiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJmb3JtYXQiLCJtYXBUcmFuc2FjdGlvblN0YXR1cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});